(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{39:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(3),o=n(9),r=(n(0),n(414)),i={title:"Build your first Dapp with RenJS",description:"Building a simple marketplace on Ethereum",slug:"build-a-dapp-with-renjs",author:"Tejas",author_title:"Developer Relations at Ren",author_url:"https://github.com/terrafirmatrekker",author_image_url:"https://avatars.githubusercontent.com/u/11544711?s=60&v=4",tags:["RenVM","RenJS","dapp","tutorial"],image:"https://avatars.githubusercontent.com/u/11544711?s=60&v=4",hide_table_of_contents:!1},s={permalink:"/ren-client-docs/blog/build-a-dapp-with-renjs",editUrl:"https://github.com/renproject/ren-client-docs/edit/master/blog/2021-09-08-build-a-dapp-with-renjs.md",source:"@site/blog/2021-09-08-build-a-dapp-with-renjs.md",description:"Building a simple marketplace on Ethereum",date:"2021-09-08T00:00:00.000Z",formattedDate:"September 8, 2021",tags:[{label:"RenVM",permalink:"/ren-client-docs/blog/tags/ren-vm"},{label:"RenJS",permalink:"/ren-client-docs/blog/tags/ren-js"},{label:"dapp",permalink:"/ren-client-docs/blog/tags/dapp"},{label:"tutorial",permalink:"/ren-client-docs/blog/tags/tutorial"}],title:"Build your first Dapp with RenJS",readingTime:21.495,truncated:!0},c=[{value:"<strong>Part 1: Getting Started</strong>",id:"part-1-getting-started",children:[]},{value:"<strong> Part 2: Smart Contracts</strong>",id:"part-2-smart-contracts",children:[]},{value:"<strong>Part 2: Interacting with RenVM</strong>",id:"part-2-interacting-with-renvm",children:[]},{value:"<strong>Part 3: Integrating with RenJS</strong>",id:"part-3-integrating-with-renjs",children:[]},{value:"<strong>Conclusion </strong>",id:"conclusion",children:[]}],l={toc:c};function d(e){var t=e.components,n=Object(o.default)(e,["components"]);return Object(r.mdx)("wrapper",Object(a.default)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.mdx)("p",null,"Our dapp will be powered by a smart contract that will track the ownership of products and instantly transfer ownership after a product is purchased by another user. One feature that will be unique is that users will be able to bridge Bitcoin in so our users can participate in the Ethereum ecosystem, this will be achieved by utilizing RenJS in our dapp."),Object(r.mdx)("p",null,"RenJS is the SDK for integrating with RenVM. For more lower-level details on the inner workings of the RenVM network, check out the",Object(r.mdx)("a",{parentName:"p",href:"https://github.com/renproject/ren/wiki/Introduction"}," specification")," on GitHub."),Object(r.mdx)("h4",{id:"why-are-we-building-it"},Object(r.mdx)("strong",{parentName:"h4"},"Why are we building it?")),Object(r.mdx)("p",null,"Our approach to this tutorial is to introduce to you a simple way to familiarize yourself with some of the building blocks of dapps. It will highlight the use of smart contracts and get your feet wet building on Ethereum. Sure there are many crypto e-commerce dapps and more will pop up, but this tutorial aims to give you the basics to build on. You could use some of the concepts from the tutorial to build a number of useful dapps, or even use the experience using RenJS to apply to other",Object(r.mdx)("a",{parentName:"p",href:"https://medium.com/renproject/12-app-ideas-using-renvm-eb08fb095499"}," DeFi projects"),", the possibilities are truly limitless. If you feel comfortable with the basics and feel like jumping into RenJS, head over to our",Object(r.mdx)("a",{parentName:"p",href:"https://renproject.github.io/ren-client-docs/ren-js"}," Documentation")," and feel free to reach out on Telegram with any questions."),Object(r.mdx)("hr",null),Object(r.mdx)("h3",{id:"part-1-getting-started"},Object(r.mdx)("strong",{parentName:"h3"},"Part 1: Getting Started")),Object(r.mdx)("h4",{id:"configuring-your-developer-environment"},Object(r.mdx)("strong",{parentName:"h4"},"Configuring your Developer Environment")),Object(r.mdx)("p",null,"This tutorial assumes that you already have Node installed in order to use NPM. If you need to install Node you can visit the ",Object(r.mdx)("a",{parentName:"p",href:"https://nodejs.org/en/"},"Node.js website")," to download it. Let\u2019s begin the tutorial by getting the rest of our project\u2019s dependencies installed. First, we are going to install and set up Ganache."),Object(r.mdx)("h4",{id:"ganache"},Object(r.mdx)("strong",{parentName:"h4"},"Ganache")),Object(r.mdx)("p",null,"Ganache will enable us to use a personal blockchain to develop, deploy, and test the dapp locally before we deploy it to Kovan testnet. You can find the latest release for your OS",Object(r.mdx)("a",{parentName:"p",href:"https://www.trufflesuite.com/ganache"}," here"),". Once you\u2019ve downloaded the package, extract the installer and go through the setup."),Object(r.mdx)("p",null,"After you\u2019ve installed and opened Ganache you should see two buttons: Quickstart and New Workspace. Click New Workspace and you should see a screen with 10 accounts with 100 ether as the balances."),Object(r.mdx)("p",null,"Congratulations you now have a local blockchain up and running! By utilizing Ganache we save time avoiding blockchain development or account creation for testing. Ganache mimics the behavior of the public blockchain locally and is just one of many tools you may find useful in your Web3 developer journey."),Object(r.mdx)("h4",{id:"installing-truffle-suite"},Object(r.mdx)("strong",{parentName:"h4"},"Installing Truffle Suite")),Object(r.mdx)("p",null,"Let\u2019s install the Truffle suite next. With Truffle you will be able to do a variety of things but most importantly it can handle your smart contract management that will compile to opcode/bytecode on the Ethereum Virtual Machine (EVM). It can also automate testing, handle network management; basically a ton of stuff. I won\u2019t get too much into Truffle but if you feel comfortable with some of the concepts in dapp development I recommend",Object(r.mdx)("a",{parentName:"p",href:"https://www.trufflesuite.com/boxes"}," Truffle Boxes")," which are useful boilerplates to get you up and running quickly."),Object(r.mdx)("p",null,"To install Truffle open your terminal and follow the instructions",Object(r.mdx)("a",{parentName:"p",href:"https://www.trufflesuite.com/docs/truffle/getting-started/installation"}," here"),". Alternatively, if you feel like diving into the project without installing Truffle globally or you just want to toy around with the code, you can clone the repo (link) and run npm since Truffle and all the other dependencies are included. So to install Truffe head over to the terminal and type"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-sh"},"npm install truffle -g\n")),Object(r.mdx)("h4",{id:"setting-up-metamask"},Object(r.mdx)("strong",{parentName:"h4"},"Setting up Metamask")),Object(r.mdx)("p",null,"If you don\u2019t already have Metamask installed, now is the time to do so. Metamask enables you to utilize your browser to send and receive Ethereum and ERC20s. Available as a browser extension and as a mobile app, MetaMask equips you with a key vault, secure login, token wallet, and token exchange\u200a\u2014\u200aeverything you need to manage your digital assets. For the purpose of the tutorial, we will use the Metamask extension for Google Chrome."),Object(r.mdx)("p",null,"To install Metamask check out their",Object(r.mdx)("a",{parentName:"p",href:"https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en"}," extension")," and follow their instructions to get it set up. Make sure that you see the extension activated as denoted by the fox icon along your browser\u2019s address bar."),Object(r.mdx)("h4",{id:"cloning-the-project-repo"},Object(r.mdx)("strong",{parentName:"h4"},"Cloning the project repo")),Object(r.mdx)("p",null,"Instead of going through the rigamarole of getting your project\u2019s directory set up, I created a clonable repo based off the Create ETH app that has all the Ren dependencies you might need to get things moving quickly, just head over to this repo (link) and clone it by typing:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-sh"},"git clone https://github.com/terrafirmatrekker/Nakamoto-Store-Demo\n")),Object(r.mdx)("p",null,"Now cd into the directory that you cloned and you should be ready to go! Looking at our project directory you should see a simple truffle project configuration to help you build many dapps including some of the best packages from Ren, even though we only actually need two. I definitely recommend checking out all of the",Object(r.mdx)("a",{parentName:"p",href:"https://github.com/renproject/ren-js"}," integration options we have"),". With this basic project setup, you can create and test smart contracts, develop modern frontend applications. You can check out the dependencies in the package.json file if you\u2019d like. To install the dependencies head over to the terminal with the project directory selected and type:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-sh"},"npm install\n")),Object(r.mdx)("p",null,"In the project directory you will notice a truffle-config file. This file is used to connect to our dapp\u2019s blockchain network. In the file you will see configurations to connect to the Ganache blockchain (127.0.0.1:7545). We will get into the rest of the files in the directory as they pertain to the project. The other important items to consider in the directory is the components folder which is based on a starter template for our React frontend and simple tests written in Mocha and with the Chai assertion library, which I used to test our smart contracts, but you can use as a reference. We will go over the rest in the remainder of this tutorial."),Object(r.mdx)("hr",null),Object(r.mdx)("h3",{id:"part-2-smart-contracts"},Object(r.mdx)("strong",{parentName:"h3"}," Part 2: Smart Contracts")),Object(r.mdx)("p",null,"A \u201csmart contract\u201d is simply a program that runs on the Ethereum blockchain. It\u2019s a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain."),Object(r.mdx)("p",null,"You can think of smart contracts as a type of Ethereum account which means they have a balance and can process transactions over the network. What is truly unique about smart contracts is the fact that they are not controlled by an individual, once they are deployed to the network they run as they are programmed, immutable by nature."),Object(r.mdx)("p",null,"Some would equate smart contracts to a \u201cbackend,\u201d or a microservice or APIs (smart contracts are public on Ethereum and can be interacted with), but it\u2019s far bigger than that. Not to drone on about smart contracts, but really at the end of the day these little files with op/bytecode are the meat and potatoes of Web3, they enable dapps to do a tremendous amount of things in the background. I don\u2019t like to make predictions but as I see it many, if not most sectors in the future, will be impacted by smart contracts. From finance to gaming, exchanges, and media dapps\u200a\u2014\u200athey all utilize smart contracts in many different ways."),Object(r.mdx)("p",null,"Ethereum has developer-friendly languages for writing smart contracts such as Solidity and Vyper. However, for the Ethereum Virtual Machine (EVM) to run your contract it needs to be in bytecode. We will do this through compilation via the",Object(r.mdx)("a",{parentName:"p",href:"https://remix.ethereum.org/"}," Remix IDE"),", which is an open-source web and desktop application that affords devs a fast development cycle with a rich set of plugins and intuitive GUIs. Remix will be used for your entire journey of smart contract development and can serve as a veritable playground for learning Ethereum. Our smart contracts will be written in Solidity for this tutorial. If you already feel comfortable with Solidity and are curious about how to integrate with Ren and Ren JS check out this",Object(r.mdx)("a",{parentName:"p",href:"https://github.com/renproject/ren-solidity-template"}," repo")," for a template."),Object(r.mdx)("p",null,"There is one gotcha for most use cases, smart contracts cannot retrieve information from the \u201creal-world\u201d because of their inability to send HTTP requests. This was a product of design since reliance on external sources could jeopardize security and the goal of decentralization. Dapps use",Object(r.mdx)("a",{parentName:"p",href:"https://ethereum.org/en/developers/docs/oracles/"}," oracles")," for such information but there are workarounds."),Object(r.mdx)("p",null,"It is a good idea to use audited and pre-built smart contracts which are used throughout the ecosystem. A great resource is",Object(r.mdx)("a",{parentName:"p",href:"https://github.com/OpenZeppelin/openzeppelin-contracts"}," OpenZeppelin")," who regularly undergoes audits and contributes to the composable nature of smart contracts."),Object(r.mdx)("h4",{id:"our-contract"},Object(r.mdx)("strong",{parentName:"h4"},"Our Contract")),Object(r.mdx)("p",null,"Our contract will do some simple things, but when you take a step back and realize that the data from our contract interactions are immutable, that is where you will see the awesome power of smart contracts. It is amazing how quickly cryptocurrency and blockchains have evolved, in fact, the first transaction with Bitcoin was only 10 years ago when programmer Laszlo Hanyecz bought two Papa John\u2019s pizzas for[ \u20bf",Object(r.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Bitcoin#:~:text=In%202010%2C%20the%20first%20known,John%27s%20pizzas%20for%20%E2%82%BF10%2C000"},"10,000"),"]. Now you can do a tremendous amount of things with smart contracts such as speculate on derivatives, lend and borrow cryptocurrencies, swap and stake tokens, buy art, or even insurance."),Object(r.mdx)("p",null,"The thing that excites me about RenVM is its ability to empower smart contracts in a totally different way. A world with fully autonomous smart contracts working with chain-to-chain interactions is something that will change how the world works. Imagine, programmable bots trained by algorithms just moving and trading assets, decentralized, and free of humans. Simply reacting to events in the real world and following their instructions. Pretty incredible stuff and things that I expect is in the very near future."),Object(r.mdx)("p",null,"Instead of going through the entire contract, I am going to explain some of the key bits that are necessary to understand the dapps functionality. To get started open the file named Marketplace.sol in the IDE of your choice."),Object(r.mdx)("p",null,"First, you will see the version of Solidity declared:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-sol"},"pragma solidity ^0.5.0;\n")),Object(r.mdx)("p",null,"Below it we will declare our smart contract Marketplace which creates a state variable that will be stored on the blockchain. All of our smart contract code will be written inside the curly braces as you can see. You will also see a variable called name which we use for testing and we declare it public so we can read its value outside of the contract."),Object(r.mdx)("p",null,"Below you can see a struct to allow us to list products:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-sol"},"struct Product {\n    uint256 id;\n    string name;\n    uint256 price;\n    address payable owner;\n    bool purchased;\n}\n")),Object(r.mdx)("p",null,"We can treat a struct like a value type such that it can be used within arrays and mappings. You can see the struct members, which consist of variable names along with their types. Solidity enables you to create your own data structures, with any attributes. That\u2019s exactly what is done by creating a Product struct. It stores all the attributes of a product that we\u2019ll need, like id, name, price, owner, and a boolean to determine if it is purchased. Now let\u2019s jump back up a few lines you may have noticed these two lines which I didn\u2019t explain:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-sol"},"uint256 public productCount = 0;\nmapping(uint256 => Product) public products;\n")),Object(r.mdx)("p",null,"The first line is to keep track of how many products exist in the smart contract. We initialize it with 0 to begin. The second line is used to store the products on the blockchain. We use mapping to achieve this. According to the Solidity docs, \u201cmappings can be seen as hash tables which are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation are all zeros.\u201d"),Object(r.mdx)("p",null,"Let\u2019s go below the Product struct we created and you should see two event definitions that correspond to the functions below it. The first event relates to when a product is created, and the second pertains to when a product is purchased. These work almost exactly the same"),Object(r.mdx)("p",null,"Looking at the function related to the events you can see ",Object(r.mdx)("strong",{parentName:"p"},"createProduct"),". Let\u2019s break this function down a bit. This function will accept a name, price (in Wei), and check for conditions that the name is and price is greater than 0. Below that you see a line called ",Object(r.mdx)("strong",{parentName:"p"},"productCount++"),"; This is used to create a new Product id by utilizing the increment operator (++). Then we create a new product and add it to the mapping. ",Object(r.mdx)("strong",{parentName:"p"},"msg.sender")," is the address of the user creating the product. Last you see, ",Object(r.mdx)("strong",{parentName:"p"},"emit ProductCreated")," which is what emits the event to notify that a product was created. Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transaction\u2019s log\u200a\u2014\u200aa special data structure in the blockchain. These logs are associated with the address of the contract, are incorporated into the blockchain, and stay there as long as a block is accessible."),Object(r.mdx)("p",null,"Now let\u2019s break down the second function corresponding to the event ",Object(r.mdx)("strong",{parentName:"p"},"ProductPurchased"),". First we get the product from the mapping we created and store the current owner to a variable. We have a few requirements below demarcated by ",Object(r.mdx)("strong",{parentName:"p"},"require"),". The requirements are a valid id, sufficient Ether for the transaction, the buyer is not the seller, and the product is still unpurchased. Next after the requirements are met we allow for the transaction to occur. We transfer ownership of the product to the buyer, mark the product as bought, and send the Ether to the seller. Finally, the event is emitted to show that a product has been purchased."),Object(r.mdx)("p",null,"Wow, we covered a ton of information in a short span of time! So by now you should have the tools to mimic a public blockchain through Ganache, the Truffle suite to automate testing with the test files and do a variety of things. We have also reviewed quite a bit on smart contracts, I encourage you to read the",Object(r.mdx)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.6/"}," Solidity documentation")," to further develop your understanding. You may also consider",Object(r.mdx)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.1/solidity-by-example.html#"}," their examples")," to develop some of your own basic dapps. There are also many open-source resources to get you started. If you have a desire to dig deeper on some of the concepts, a few things that helped me understand concepts better:"),Object(r.mdx)("ul",null,Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("a",{parentName:"li",href:"https://andersbrownworth.com/blockchain/"},"Visualizing the blockchain"),": a professor has some examples of keys, blockchains and various other demos"),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("a",{parentName:"li",href:"https://ocw.mit.edu/courses/sloan-school-of-management/15-s12-blockchain-and-money-fall-2018/index.htm"},"MIT Mooc Blockchain and Money"),": In particular Sessions 2\u20134 (relevant to Week 3 of Notion), & 6 ( a great course in its entirety)"),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("a",{parentName:"li",href:"https://eth.build/"},"ETH Builder"),": I think the dev behind this illustrates the",Object(r.mdx)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=zcX7OJ-L8XQ"}," Blockchain")," and",Object(r.mdx)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=-6aYBdnJ-nM"}," Smart Contracts")," pretty well. In fact besides his connection to Ethereum, I think a visualization of RenVM via the same open-source toolset would be great as well!"),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("a",{parentName:"li",href:"https://blog.openzeppelin.com/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05/%29,%20%5BA%20Gentle%20Intro%20to%20Ethereum%20Programming%5D%28https://blog.openzeppelin.com/designing-the-architecture-for-your-ethereum-application-9cec086f8317/"},"Hitchhiker\u2019s Guide to Smart Contracts")),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("a",{parentName:"li",href:"https://medium.com/blockchain-at-berkeley/introduction-to-blockchain-through-cryptoeconomics-part-1-bitcoin-369f245067f9"},"Introduction to Blockchain through Cryptoeconomics"))),Object(r.mdx)("p",null,"In Part 2 and 3 I will outline some of the components of our dapp like the Store\u2019s frontend, a frontpage, a \u201cbridge\u201d where we will interact with RenVM to allow customers to convert BTC to renBTC to use in the shop, and more on other ways you can use RenVM."),Object(r.mdx)("hr",null),Object(r.mdx)("h3",{id:"part-2-interacting-with-renvm"},Object(r.mdx)("strong",{parentName:"h3"},"Part 2: Interacting with RenVM")),Object(r.mdx)("p",null,"Now that we have our store smart contract created and tests in place to assure it is functioning as we planned we can move to one final task with Solidity before deploying our contract to Kovan, which is the use of an \u201cadapter contract\u201d to bring renBTC to our dapp so customers can purchase products with BTC."),Object(r.mdx)("p",null,"The BasicAdapter contract is not part of the core RenVM protocol contracts and is only used by the front-end RenJS library. It\u2019s a contract that submits mint signatures to a MintGateway and then forwards the minted ren-asset to the specified recipient. You can find",Object(r.mdx)("a",{parentName:"p",href:"https://github.com/renproject/gateway-sol"}," examples")," and",Object(r.mdx)("a",{parentName:"p",href:"https://github.com/renproject/ren-solidity-template"}," templates")," in Ren\u2019s repos."),Object(r.mdx)("p",null,"Looking at our smart contract some things to note would be the use of interfaces. Interfaces are the same as abstract contracts created by using an interface keyword, also known as a pure abstract contract. Interfaces do not have any definition or any state variables, constructors, or any function with implementation, they only contain function declarations i.e. functions in interfaces do not have any statements. The idea is to use inheritance to create a compliant implementation\u200a\u2014\u200aa contract with the exact same functions implemented. Anyone can implement these functions in the contract."),Object(r.mdx)("p",null,"In our contract you should notice the use of the IGateway interface with two function declarations mint and burn:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-sol"},"interface IGateway {\n    function mint(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) external returns (uint256);\n    function burn(bytes calldata _to, uint256 _amount) external returns (uint256);\n}\n")),Object(r.mdx)("p",null,"For our dapp we will only implement mint since our users will send BTC and mint renBTC which is an ERC20 token that can be used in our store. You can see the implementation in the mint function:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-sol"},"function mint(\n    // Payload\n    string calldata _symbol,\n    address _recipient,\n    // Required\n    uint256 _amount,\n    bytes32 _nHash,\n    bytes calldata _sig\n) external {\n    bytes32 payloadHash = keccak256(abi.encode(_symbol, _recipient));\n    uint256 amount = registry.getGatewayBySymbol(_symbol).mint(\n    payloadHash,\n    _amount,\n    _nHash,\n    _sig\n);\n    registry.getTokenBySymbol(\u201cBTC\u201d).transfer(msg.sender, amount);\n}\n")),Object(r.mdx)("p",null,"You can interact with this contract that is already deployed on Kovan",Object(r.mdx)("a",{parentName:"p",href:"https://kovan.etherscan.io/address/0x7e5c5fc517ad27070faf8b2ac05d06bf0250332d"}," here"),". To deploy your own version of the contract following the instructions at the bottom of our",Object(r.mdx)("a",{parentName:"p",href:"https://renproject.github.io/ren-client-docs/ren-js/tutorial/smart-contract/"}," tutorial")," labeled: ",Object(r.mdx)("em",{parentName:"p"},"Deploying to Kovan. ")),Object(r.mdx)("p",null,Object(r.mdx)("strong",{parentName:"p"},"Remember to deploy to GatewayRegistry\u2019s address, 0x557e211EC5fc9a6737d2C6b7a1aDe3e0C11A8D5D")),Object(r.mdx)("p",null,"At this point we can move to the frontend integration of RenJS. For the purposes of the tutorial, we are going to cover the integration but the store itself is fully functional and can be used to sell and buy products on the blockchain with ethers."),Object(r.mdx)("hr",null),Object(r.mdx)("h3",{id:"part-3-integrating-with-renjs"},Object(r.mdx)("strong",{parentName:"h3"},"Part 3: Integrating with RenJS")),Object(r.mdx)("p",null,"As I mentioned in Part 2, the store as is totally functional if you are using ethers as a method of payment. But let\u2019s make it possible for users to convert BTC to renBTC a 1:1 ERC-20 token representation of Bitcoin (BTC) on Ethereum."),Object(r.mdx)("p",null,"We have already laid the foundation for adapting our smart contract to use RenJS the official SDK for interacting with RenVM. As I intimated before our users will only require a mint transaction, technically speaking a lock-and-mint transaction."),Object(r.mdx)("p",null,"Lock-and-mint transactions are so named because the first step requires the user to send assets to RenVM, thereby \u201clocking\u201d into its custody. Unless there is consensus in RenVM that the assets can be released, they will remain locked. After witnessing the locking of assets, RenVM returns a \u201cminting signature\u201d to the user. This authorizes the user to mint a tokenized representation of the asset on the host chain. This representation is pegged one-to-one with the locked asset; it is always redeemable in any quantity at any time. You can learn more about cross-chain transactions",Object(r.mdx)("a",{parentName:"p",href:"https://github.com/renproject/ren/wiki#cross-chain-transactions"}," here"),"."),Object(r.mdx)("p",null,"In fact, you would not need the adapter contract if your dapp was merely minting and burning assets. In our Developer Docs we have a",Object(r.mdx)("a",{parentName:"p",href:"https://renproject.github.io/ren-client-docs/ren-js/quick-start"}," quick start section")," that illustrates how easy it is to mint and burn assets if you are a developer familiar with Web3. Check out the code below to mint a tokenized Bitcoin."),Object(r.mdx)("p",null,"Back to those following along less familiar with Web3, navigate to the component sub-folder in your project directory. As this project is a react app we have several different components, feel free to explore the components to understand how we use",Object(r.mdx)("a",{parentName:"p",href:"https://web3js.readthedocs.io/en/v1.5.2/"}," Web3.js")," to wire the frontend to communicate with smart contracts. The component that highlights the integration of RenJS is named Bridge.js. Open up this component in your IDE and follow along as I explain what is happening. You can also check out our",Object(r.mdx)("a",{parentName:"p",href:"https://renproject.github.io/ren-client-docs/ren-js/tutorial/ren-js"}," RenJS tutorial")," whose code I adapted for the purposes of the demo."),Object(r.mdx)("p",null,"RenJS allows developers to interact with RenVM\u2019s growing network of bridged chains and assets. It\u2019s the official JavaScript SDK for interacting with RenVM and for bridging assets."),Object(r.mdx)("p",null,"First you will need to install 2 packages:"),Object(r.mdx)("ul",null,Object(r.mdx)("li",{parentName:"ul"},"@renproject/ren implements the core logic for interacting with RenVM"),Object(r.mdx)("li",{parentName:"ul"},"@renproject/chains provides support for various assets and chains. These can also be imported separately as I have done- e.g. using @renproject/chains-ethereum for Ethereum")),Object(r.mdx)("p",null,"I have imported these packages at the top of my component file. Next, I initialize RenJS, I initialize it with the parameter \u201ctestnet\u201d on line 19 to connect to RenVM\u2019s testnet."),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-ts"},"renJS: new RenJS(\u201ctestnet\u201d),\n")),Object(r.mdx)("p",null,"As I intimated before there are two steps involves in creating new renBTC tokens on Ethereum\u200a\u2014\u200a1) locking BTC and 2) minting renBTC. The method on RenJS to initiate this process is called a lockAndMint. You can read more about this interface in our",Object(r.mdx)("a",{parentName:"p",href:"https://renproject.github.io/ren-js-docs/index.html"}," TypeDocs"),". Here's what it looks like to set-up a lockAndMint to a user's address on Ethereum:"),Object(r.mdx)("p",null,"Though for our dapp we want to send BTC to a smart contract, not just a user\u2019s address. To do this, we specify the details needed to call the smart contract. You can see a const variable on line 20 with the address of the smart contract we created."),Object(r.mdx)("p",null,"Each LockAndMint object has a unique ",Object(r.mdx)("em",{parentName:"p"},"gateway address"),", generated from the details we provided to it. We want to show the gateway address to the user and then wait for them to send BTC to this address. We do this on line 145 by adding:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-ts"},"alert(`Deposit ${amount} BTC to ${mint.gatewayAddress}`);\n")),Object(r.mdx)("p",null,'To handle deposits received at the gateway address, the mint object emits "deposit" events that can be listened to using mint.on("deposit", ...). After detecting a deposit, there are three steps for completing the asset bridging:'),Object(r.mdx)("ol",null,Object(r.mdx)("li",{parentName:"ol"},"waiting for the deposit to be confirmed,"),Object(r.mdx)("li",{parentName:"ol"},"submitting the deposit to RenVM and wait for a signature, and"),Object(r.mdx)("li",{parentName:"ol"},"submitting to the mint-chain\u200a\u2014\u200ain the dapp this is Ethereum.")),Object(r.mdx)("p",null,'We perform these steps inside the "deposit" event callback on lines 147\u2013164'),Object(r.mdx)("p",null,"We then alert the user of the BTC deposited:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-ts"},"alert(`Deposited ${amount} BTC.`);\n")),Object(r.mdx)("p",null,'To check on the status of the deposit we can usedeposit.status which returns the current progress of the deposit, and will be "detected", "confirmed", "signed", "submitted" or "reverted". (',Object(r.mdx)("em",{parentName:"p"},"See",Object(r.mdx)("a",{parentName:"em",href:"https://renproject.github.io/ren-js-docs/enums/depositstatus.html"}," DepositStatus docs")),")"),Object(r.mdx)("p",null,'In addition to receiving .on("deposit", ...) events, you can also manually provide the details of a deposit using mint.processDeposit. The parameter should match the type of deposit.depositDetails of a deposit object returned from.on("deposit", ...).'),Object(r.mdx)("p",null,"Now let\u2019s say the user wanted to get their BTC back by burning their renBTC. This functionality though not utilized in the dapp is added on just to show how users can get their BTC back."),Object(r.mdx)("p",null,"In order to return the BTC back from Ethereum, the renBTC must be burned, and a recipient BTC address must be chosen. RenVM will automatically see and process the burn, releasing the BTC to the recipient. RenJS can be used to:"),Object(r.mdx)("ol",null,Object(r.mdx)("li",{parentName:"ol"},"initiate a burn by providing it the details to burn the renBTC, or"),Object(r.mdx)("li",{parentName:"ol"},"monitor an existing burn by providing it with the transaction hash or identifier of the burn.")),Object(r.mdx)("p",null,"For the sake of education here is how initiating a burn looks like: (lines 169\u2013208 in Bridge.js file):"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-ts"},'const { web3, renJS, balance } = this.state;\nconst recipient = prompt("Enter BTC recipient:");\nconst amount = balance;\nconst burnAndRelease = await renJS.burnAndRelease({\n  // Send BTC from Ethereum back to the Bitcoin blockchain.\n  asset: "BTC",\n  to: Bitcoin().Address(recipient),\n  from: Ethereum(web3.currentProvider).Contract((btcAddress) => ({\n    sendTo: contractAddress,\n\n    contractFn: "withdraw",\n\n    contractParams: [\n      {\n        type: "bytes",\n        name: "_msg",\n        value: Buffer.from(`Withdrawing ${amount} BTC`),\n      },\n      {\n        type: "bytes",\n        name: "_to",\n        value: btcAddress,\n      },\n      {\n        type: "uint256",\n        name: "_amount",\n        value: RenJS.utils.toSmallestUnit(amount, 8),\n      },\n    ],\n  })),\n});\n\nlet confirmations = 0;\nawait burnAndRelease\n  .burn()\n  // Ethereum transaction confirmations.\n  .on("confirmation", (confs) => {\n    confirmations = confs;\n  })\n  // Print Ethereum transaction hash.\n  .on("transactionHash", (txHash) => this.log(`txHash: ${String(txHash)}`));\n\nawait burnAndRelease\n  .release()\n  // Print RenVM status - "pending", "confirming" or "done".\n  .on("status", (status) =>\n    status === "confirming"\n      ? this.log(`${status} (${confirmations}/15)`)\n      : this.log(status)\n  )\n  // Print RenVM transaction hash\n  .on("txHash", this.log);\n\nthis.log(`Withdrew ${amount} BTC to ${recipient}.`);\n@terrafirmatrekker\n')),Object(r.mdx)("p",null,"If you want to try the Bridge out yourself, you will need some test ether and testBTC. Run the dapp locally in your browser if you haven\u2019t already and try it out! Once the mint is done you should be able to see testBTC in your MetaMask wallet. Just make sure to add the token to Metamask. To do so, make sure you are on Kovan Test Network in Metamask and then go to \u201cAssets\u201d and then Click \u201cAdd Token\u201d. Paste in the Kovan renBTC address (you can find it",Object(r.mdx)("a",{parentName:"p",href:"https://renproject.github.io/ren-client-docs/contracts/deployments/%29"}," here"),"\u200a\u2014\u200amake sure you\u2019ve chosen Ethereum and Testnet, and then copy the ERC20 address under testBTC."),Object(r.mdx)("h3",{id:"conclusion"},Object(r.mdx)("strong",{parentName:"h3"},"Conclusion ")),Object(r.mdx)("p",null,"Wow, we have made some tremendous progress from the beginning of this tutorial! We have created a smart contract that allows users to buy and sell products on Ethereum. Finally, we integrated with RenJS in order to interact with RenVM so users can \u201cconvert\u201d BTC to renBTC (ERC20)through a lockAndMint. There are still a few missing pieces of the puzzle that I leave up to you."),Object(r.mdx)("p",null,"Firstly, how can we modify our smart contract and front-end to allow users to shop with renBTC in lieu of Ethereum? We could possibly price the items in renBTC but that leaves a lot of users in the dark, we could also swap the renBTC for Ethers through a number of \u201cthird-party\u201d dapps. We could also use the renBTC balance inside of the contract, like a store balance/credit, so that you don\u2019t have to worry about approvals. Like when a user mints renBTC, it stays in the contract, but it gets stored in a map from the user\u2019s address to their balance. I am curious about which method you choose to implement! Send me your ideas and implementations, we want to see what you create!"),Object(r.mdx)("p",null,"Thanks for reading my tutorial, feel free to reach out to me with any questions, concerns, or modifications you have made to the dapp. Also, feel free to join Ren\u2019s",Object(r.mdx)("a",{parentName:"p",href:"https://t.me/joinchat/xED0D5pCfVI1YWU5"}," telegram")," to ask technical questions and to learn more about the ecosystem and protocol. Remember, things are only impossible until they\u2019re not! There is so much to #buidl show us what you dream up!"))}d.isMDXComponent=!0},414:function(e,t,n){"use strict";n.r(t),n.d(t,"MDXContext",(function(){return d})),n.d(t,"MDXProvider",(function(){return m})),n.d(t,"mdx",(function(){return f})),n.d(t,"useMDXComponents",(function(){return h})),n.d(t,"withMDXComponents",(function(){return u}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return(i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=o.a.createContext({}),u=function(e){return function(t){var n=h(t.components);return o.a.createElement(e,i({},t,{components:n}))}},h=function(e){var t=o.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},m=function(e){var t=h(e.components);return o.a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},b=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=h(n),u=a,m=d["".concat(i,".").concat(u)]||d[u]||p[u]||r;return n?o.a.createElement(m,c(c({ref:t},s),{},{components:n})):o.a.createElement(m,c({ref:t},s))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);